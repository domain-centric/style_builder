// Copyright (c) 2025 Nils ten Hoeve, licensed under the 3-Clause BSD License

// ignore_for_file: deprecated_member_use

import 'package:dart_code/dart_code.dart';
import 'package:style_builder/src/code/type_converter.dart';
import 'package:style_builder/src/code/lerp_expression.dart';
import 'package:style_builder/src/source_class.dart';

class StyleClass extends Class {
  StyleClass(SourceClass sourceClass)
    : super(
        sourceClass.styleClassName,
        superClass: themeExtensionType(sourceClass),
        docComments: createDocComments(sourceClass),
        fields: createFields(sourceClass),
        constructors: createConstructors(sourceClass),
        methods: createMethods(sourceClass),
      );

  static List<DocComment> createDocComments(SourceClass sourceClass) => [
    DocComment.fromList([
      'This class is generated by the style_builder package. Do not edit manually.',
      'Source class : ${sourceClass.classType.getDisplayString()}',
      'To update run: dart run build_runner build --delete-conflicting-output',
      'For more info: https://pub.dev/packages/style_builder',
    ]),
  ];

  static List<Field> createFields(SourceClass sourceClass) => [
    for (var defaultAccessor in sourceClass.defaultAccessors)
      Field(
        defaultAccessor.name,
        modifier: Modifier.final$,
        type: toDartCodeType(defaultAccessor.type, nullable: true),
      ),
    createDefaultsField(sourceClass),
  ];

  static List<Method> createMethods(SourceClass sourceClass) => [
    ResolveMethod(sourceClass),
    CopyWithMethod(sourceClass),
    LerpMethod(sourceClass),
    ToStringMethod(sourceClass),
    HashCodeMethod(sourceClass),
    EqualsMethod(sourceClass),
  ];

  static Field createDefaultsField(SourceClass sourceClass) => Field(
    'defaults',
    static: true,
    modifier: Modifier.const$,
    type: toDartCodeType(sourceClass.classType, nullable: false),
    value: Expression.callConstructor(toDartCodeType(sourceClass.classType)),
  );

  static List<Constructor> createConstructors(SourceClass sourceClass) => [
    Constructor(
      Type(sourceClass.styleClassName),
      constant: true,
      parameters: createConstructorParameters(sourceClass),
    ),
  ];

  static ConstructorParameters createConstructorParameters(
    SourceClass sourceClass,
  ) => ConstructorParameters([
    for (var defaultAccessors in sourceClass.defaultAccessors)
      ConstructorParameter.named(
        this$: true,
        defaultAccessors.name,
        type: toDartCodeType(defaultAccessors.type, nullable: true),
      ),
  ]);
}

class ResolveMethod extends Method {
  static const flutterMaterialPackageUri = 'package:flutter/material.dart';

  ResolveMethod(SourceClass sourceClass)
    : super.static(
        'resolve',
        createBody(sourceClass),
        docComments: createDocComments(sourceClass),
        returnType: createReturnType(sourceClass),
        parameters: createMethodParameters(sourceClass),
      );

  static Record createReturnType(SourceClass sourceClass) => Record([
    for (var defaultAccessor in sourceClass.defaultAccessors)
      RecordField.named(
        toDartCodeType(defaultAccessor.type, nullable: false),
        defaultAccessor.name,
      ),
  ]);

  static CodeNode createBody(SourceClass sourceClass) =>
      Block([declareThemeVariable(sourceClass), returnRecord(sourceClass)]);

  static declareThemeVariable(SourceClass sourceClass) => VariableDefinition(
    'theme',
    type: Type.ofVar(),
    value: Expression.callConstructor(
      Type('Theme', libraryUri: flutterMaterialPackageUri),
      name: 'of',
      parameterValues: ParameterValues([
        ParameterValue(Expression.ofVariable('context')),
      ]),
    ).callMethod('extension', genericType: Type(sourceClass.styleClassName)),
  );

  static Parameters createMethodParameters(SourceClass sourceClass) =>
      Parameters([
        Parameter.required(
          'context',
          type: Type('BuildContext', libraryUri: flutterMaterialPackageUri),
        ),
        Parameter.optional(
          'style',
          type: Type(sourceClass.styleClassName, nullable: true),
        ),
      ]);

  static List<DocComment> createDocComments(SourceClass sourceClass) => [
    DocComment.fromList([
      'Resolves the ${sourceClass.styleClassName} within the current context / theme',
      'and returns a record with non nullable values.',
      'The values are resolved in the following order:',
      '1. The value from the provided style (e.g. a constructor parameter of a widget)',
      '2. The value from the theme extension',
      '3. The default value from the annotated class',
    ]),
  ];

  static Statement returnRecord(SourceClass sourceClass) => Statement.return$(
    Expression.ofRecord([
      for (var defaultAccessor in sourceClass.defaultAccessors)
        RecordFieldValue.named(
          defaultAccessor.name,
          Expression([
            Code(
              'style?.${defaultAccessor.name} ?? '
              'theme?.${defaultAccessor.name} ?? '
              'defaults.${_defaultAccessor(defaultAccessor)}',
            ),
          ]),
        ),
    ]),
  );

  static _defaultAccessor(DefaultAccessor defaultAccessor) {
    if (defaultAccessor is DefaultField) {
      return defaultAccessor.name;
    }
    if (defaultAccessor is DefaultMethod) {
      if (defaultAccessor.hasBuildContextParameter) {
        return '${defaultAccessor.name}(context)';
      } else {
        return '${defaultAccessor.name}()';
      }
    }
  }
}

class CopyWithMethod extends Method {
  CopyWithMethod(SourceClass sourceClass)
    : super(
        'copyWith',
        createBody(sourceClass),
        parameters: createMethodParameters(sourceClass),
        annotations: [Annotation.override()],
        docComments: createDocComments(sourceClass),
        returnType: Type(sourceClass.styleClassName),
      );

  static List<DocComment> createDocComments(SourceClass sourceClass) {
    return [
      DocComment.fromList([
        'Creates a copy of this ${sourceClass.styleClassName} with the current values',
        'replaced by given none-null parameter values.',
      ]),
    ];
  }

  static CodeNode createBody(SourceClass sourceClass) =>
      Expression.callConstructor(
        Type(sourceClass.styleClassName),
        parameterValues: createConstructorParameterValues(sourceClass),
      );

  static Parameters createMethodParameters(SourceClass sourceClass) =>
      Parameters([
        for (var defaultAccessor in sourceClass.defaultAccessors)
          Parameter.named(
            defaultAccessor.name,
            type: toDartCodeType(defaultAccessor.type, nullable: true),
          ),
      ]);

  static ParameterValues createConstructorParameterValues(
    SourceClass sourceClass,
  ) => ParameterValues([
    for (var defaultAccessor in sourceClass.defaultAccessors)
      ParameterValue.named(
        defaultAccessor.name,
        Expression.ofVariable(
          defaultAccessor.name,
        ).ifNull(Expression.ofThis().getProperty(defaultAccessor.name)),
      ),
  ]);
}

class LerpMethod extends Method {
  LerpMethod(SourceClass sourceClass)
    : super(
        'lerp',
        createBody(sourceClass),
        parameters: createMethodParameters(sourceClass),
        annotations: [Annotation.override()],
        docComments: createDocComments,
        returnType: themeExtensionType(sourceClass),
      );

  static List<DocComment> get createDocComments {
    return [
      DocComment.fromList([
        'Linearly interpolate with another [ThemeExtension] object.',
        'The following types are supported:',
        '* bool',
        '* Enum',
        '* int',
        '* double',
        '* all classes with a correct static lerp method, e.g. Color.lerp(a,b,t)',
      ]),
    ];
  }

  static Parameters createMethodParameters(SourceClass sourceClass) =>
      Parameters([
        Parameter.required(
          'other',
          type: Type(sourceClass.styleClassName, nullable: true),
        ),
        Parameter.required('t', type: Type.ofDouble(nullable: false)),
      ]);

  static CodeNode createBody(SourceClass sourceClass) =>
      Expression.ofVariable('other')
          .equalTo(Expression.ofNull())
          .conditional(
            Expression.ofThis(),
            Expression.callConstructor(
              Type(sourceClass.styleClassName),
              parameterValues: createConstructorParameterValues(sourceClass),
            ),
          );

  static ParameterValues createConstructorParameterValues(
    SourceClass sourceClass,
  ) {
    var factory = LerpExpressionFactories();
    var parameterValues = <ParameterValue>[];
    for (var defaultAccessor in sourceClass.defaultAccessors) {
      var expression = factory.createLerpExpression(defaultAccessor);
      if (expression != null) {
        parameterValues.add(
          ParameterValue.named(defaultAccessor.name, expression),
        );
      }
    }
    return ParameterValues(parameterValues);
  }
}

Type themeExtensionType(SourceClass sourceClass) => Type(
  'ThemeExtension',
  libraryUri: 'package:flutter/material.dart',
  generics: [Type(sourceClass.styleClassName)],
);

// Creates a toString method for the style class
// Example:
// @override
//       String toString() {
//       final values = <String>[
//         if (borderRadius != null) 'borderRadius: $borderRadius',
//         if (elevation != null) 'elevation: $elevation',
//       ];
//       return 'MyWidgetStyle(${values.join(', ')})';
//       }
class ToStringMethod extends Method {
  ToStringMethod(SourceClass sourceClass)
    : super(
        'toString',
        createBody(sourceClass),
        annotations: [Annotation.override()],
        returnType: Type.ofString(),
      );

  static CodeNode createBody(SourceClass sourceClass) =>
      Block([declareValuesVariable(sourceClass), returnResult(sourceClass)]);

  static Statement declareValuesVariable(SourceClass sourceClass) => Statement([
    KeyWord.final$,
    Space(),
    Statement.assignVariable(
      'values',
      Expression([
        Code('<String>['),
        for (var defaultAccessor in sourceClass.defaultAccessors)
          Code(
            ' if (${defaultAccessor.name} != null) \'${defaultAccessor.name}: \$${defaultAccessor.name}\', ',
          ),
        Code(']'),
      ]),
    ),
  ], hasEndOfStatement: false);

  static Statement returnResult(SourceClass sourceClass) => Statement.return$(
    Expression.ofString("${sourceClass.styleClassName}(\${values.join(', ')})"),
  );
}

class HashCodeMethod extends Method {
  HashCodeMethod(SourceClass sourceClass)
    : super.getter(
        'hashCode',
        createBody(sourceClass),
        annotations: [Annotation.override()],
        returnType: Type.ofInt(),
      );

  static Expression createBody(SourceClass sourceClass) =>
      Expression.ofType(Type('Object')).callMethod(
        'hash',
        parameterValues: ParameterValues([
          for (var defaultAccessor in sourceClass.defaultAccessors)
            ParameterValue(Expression.ofVariable(defaultAccessor.name)),
        ]),
      );
}

// Creates an equals method for the style class
// Example:
// @override
//       bool operator ==(Object other) =>
//       identical(this, other) ||
//       other is MyWidgetStyle &&
//       field == otherStyle.field &&  ... etc
class EqualsMethod extends Method {
  EqualsMethod(SourceClass sourceClass)
    : super.overrideOperator(
        Operator.equals,
        createBody(sourceClass),
        parameter: createMethodParameter(sourceClass),
        returnType: Type.ofBool(),
      );

  static Parameter createMethodParameter(SourceClass sourceClass) =>
      Parameter.required('other', type: Type.ofObject());

  static CodeNode createBody(SourceClass sourceClass) => Expression([
    Code('identical(this, other)'),
  ]).or(
    <Expression>[
      Expression.ofVariable(
        'other',
      ).isA(Expression.ofType(Type(sourceClass.styleClassName))),
      ...sourceClass.defaultAccessors.map(
        (defaultAccessor) =>
            Expression.ofVariable(defaultAccessor.name).equalTo(
              Expression.ofVariable('other').getProperty(defaultAccessor.name),
            ),
      ),
    ].reduce((a, b) => a.and(b)),
  );
}
